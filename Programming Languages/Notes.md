
##### Jan 30 

#### Key Terms:

- Python parser 
- Shift parser
- Parsesd Tree
- Abstract Syntax Tree
- side effect ???
- impure vs pure languages
- Parser 
- lexing example :
- Tokens:
result = oldsum - value /100

__tokens__:
- IDENT : result, ASSIGN IDENT:oldsum SUB IDENT:value DIV NUMBER:100 EOS

__The above is an example of parsing__

- ASSIGN
- SUB
- DIV
- NUMBER
- EOS

__What is the difference between lexing and lexem?__

__Lexing__ takes the lex (word) of every unit and assign a token representation for it 

Ex: var x = 12 +8 
__output of lexer__
VAR IDENT:x ASSIGN NUMBER:12 ADD NUMBER:8

##### keyword
VAR : var __the variable is unchangeble with the vale of var__
FUNCTION:function
RETURN: return
PRITN: print 

__Program__
function SquareDistance(x1, y1, x2, y2){
    return x1 ^ x2 + y1  ^ y2 
}
var distance = SquareDistance(2,3,5,6)

FUNCTION IDENT:SquareDistance LPAREN IDENT:x1 COMMA IDENT:y1 COMMA IDENT:x2 COMMA IDENT:y2 RPAREN LBRACE RETURN IDENT:x1 EXP 
IDENT:x2 ADD IDENT:y1 EXP IDENT y2 RBRACE

VAR IDENT:distance ASSIGN IDENT:SquareDistance LPAREN NUMBER:2
COMMA NUMBER:3 COMMA NUMBER:5 COMMA NUMBER:6 RPAREN

##### This language is called Quirk, it has not Bolean language

Active lexing:is scanning 


__Feb,02,2017__

__[+ -]__ ? --> ? mean options, positive and negative numbers
__\d +__ --> for digits , one or more
__"*"__---> 0 or 1
__"\ \ "__ means that all characters, or numbers
__"\.\d*"__ means all numbers from 0 to any


####### Assignment :

- Lexer
- Parser
- Interpreter



#### Feb, 06

#### Notes on How Parsers and Compilers Work

__Source File —> Scanner —> Lexer —> Parser —> Interpreter/Code Generator__

__Scanner:__ This is the first module in a compiler or interpreter. Its job is to read the source file one character at a time. It can also keep track of which line number and character is currently being read. .... For now, assume that each time the scanner is called, it returns the next character in the file.

__Lexer:__ This module serves to break up the source file into chunks (called tokens). It calls the scanner to get characters one at a time and organizes them into tokens and token types. Thus, the lexer calls the scanner to pass it one character at a time and groups them together and identifies them as tokens for the language parser (which is the next stage).

__Parser:__ This is the part of the compiler that really understands the syntax of the language. It calls the lexer to get tokens and processes the tokens per the syntax of the language.__

__Note__:
Every compiler is written to process source files in a particular language


What is EBNF ?

#### The Source Text
The source text contains the text of a program written in the specified language.

#### The Rules for a Programming Language
 At the very simplest there are three kinds of rules for a language:
- tokenizing rules
- syntactic rules
- semantic rules

__Abstract Syntax Tree (AST)__

##### Formal grammar

 __What is a formal grammar?__
- __Symbols :__  A symbol can be anything. One common example is an upper- or lower-case letter of the Roman alphabet.

- __Alphabets__: set of symbols is called an alphabet. An alphabet must be finite.

- __Strings__: A string is a finite series of symbols. All the symbols must be chosen from the same alphabet.

__Formal language__ a formal language L is any set of finite strings over that alphabet.
    
__Formal Grammar__ is a finite set of rules for generating "grammatically correct" sentences


A formal grammar has four compnenets: (__What the 4 compenets__)

- First we have a finite set Σ of terminal symbols. This is our alphabet

- Next we have a finite set N of nonterminal symbols. Non-terminal symbols are special

##### Computing : 

Formal grammars are also used to define syntactical correctness in machine languages: that is, programming languages (such as C, Java, Python,

##### Validation and parsing:

- __Validation__ is the process of determining whether a sentence is "correct"; that is, whether it is contained within the formal language generated by a grammar.

- __Parsing__ is the process of determining the grammatical structure of a sentence with respect to a formal grammar.


__Note: in the general case, parsing and validation are almost exactly the same thing. Each entails and implies the other. The only distinction is that parsing involves collecting more information.__


__Hierarchy__ is restrictions  of the formal grammars .__Grammars higher__ in the hierarchy are very powerful, but also very difficult to validate. __Grammars lower__ in the hierarchy are more constrained and have less expressive power, but they are also easier to validate.

#### Context-free grammars
In a context-free grammar, all of the production rules must start with a single __non-terminating character.__ The rule "<verb>" → "barked"i s __non-contextual__.

The rules
Ba → aB
"<noun> <verb>" → "dog barked"  
are __contextual__

